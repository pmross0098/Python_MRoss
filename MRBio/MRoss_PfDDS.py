# -*- coding: utf-8 -*-
"""
Created on Wed Dec 28 10:17:08 2022

@author: Paul Martin Ross

Module contains numerous DNA sequence manipulation functions written in 
preparation for the final of the Coursera class, 'Python for Genomic Sciences'.
Process a fasta file and find lengths, Open Reading Frames, and repeat
sequences.

"""
import Bio.SeqIO

def dict_fst(handle, splitter = ' '):
    """
    Generates a dictionary of sequences from a fasta file.

    Parameters
    ----------
    handle : string
        String pointer to a fasta file.
    splitter : string
        Character to split the fasta header on. The default is ' '.

    Returns
    -------
    Sequence Dictionary. Key is first portion of fasta header. Value is a
    tuple (full sequence, length).

    """
    out_dict = {}
    for rec in Bio.SeqIO.FastaIO.SimpleFastaParser(handle):
        out_dict[rec[0].split(splitter)[0]] = (rec[1], len(rec[1]))
        print()
    print(len(out_dict), 'fasta records read into a dictionary.')
    return(out_dict)
        
def len_records(seq_dict, mm = 'max'):
    """
    Function to return shortest or longest (min-max) sequence in the dictionary with name(s)

    Parameters
    ----------
    seq_dict : dictionary
        Sequence dictionary.
    mm : string, optional
        Specification to return longest/shortest (min/max) sequence.
        The default is 'max'.

    Returns
    -------
    A Tuple with first element a list of sequence names (1 or more) and
    second element is sequence length

    """
    # compile lengths
    lens = [seq_dict[rec][1] for rec in seq_dict]
    # determine min or max length
    m = max(lens) if mm == 'max' else min(lens)
    
    # find record of interest
    sq_nm = []
    for rec in seq_dict:
        if seq_dict[rec][1] == m:
            sq_nm.append(rec) 
    
    return((sq_nm, m))

def findORF(seq_nm, seq_dict, frame = 0):
    """
    Processes a sequence, forward strand only, to find all Open Reading 
    Frames (ORFs).

    Parameters
    ----------
    seq_nm : string
        Name of a sequence in dictionary, the key.
    seq_dict : dictionary
        Sequence dictionary.
    frame : integer, optional
        Frame to find ORFs in, [0,1,2], which equate to 1,2,3 in common
        biology parlance. The default is 0.

    Returns
    -------
    List of lists, specifying ORFs , start location **(+1)**, ORF length
    ** This is Base number for starting base position, **NOT** python base 0.

    """
    seq = seq_dict[seq_nm][0]
    orf_list = []
    # Is there a Start codon?
    for j in range(frame, len(seq), 3):
        # print(seq[j:j+3])
        if seq[j:j+3] == 'ATG':
            # print('Found one! Base:', j+1, '\nFrame:', frame+1)
            # is there a stop codon?
            for k in range(j, len(seq), 3):
                if seq[k:k+3] in ['TAA','TAG','TGA']:
                    # print(seq[j:k+3])
                    orf_list.append([j+1, k-j+3]) # NOT base 0
                    break
    return(orf_list)

def maxORF_file_frame(seq_dict, frame = 0):
    """
    Finds longest Open Reading Frame (ORF) in a given frame within a sequence
    dictionary.

    Parameters
    ----------
    seq_dict : dictionary
        Sequence dictionary.
    frame : integer, optional
        Frame to find ORFs in, [0,1,2], which equate to 1,2,3 in common
        biology parlance. The default is 0.

    Returns
    -------
    A list [sequence name, coordinates (two-item list) in python base 0, 
            and sequence of longest ORF].

    """
    lngst = ['',[0,0], '']
    for seq_nm in seq_dict:
        orfs = findORF(seq_nm, seq_dict, frame)
        # Must be ORF for this part, otherwise skip
        if len(orfs) != 0:
            locmx = maxORF(orfs)
            lngst = [seq_nm, locmx, seq_dict[seq_nm][0][locmx[0]-1:locmx[0]+locmx[1]-1]] if locmx[1] > lngst[1][1] else lngst
    return(lngst)

def maxORF(ORF_list):
    """
    Finds the longest/shortest Open Reading Frame (ORF) in an ORF list 
    generated by the 'findORF' function.

    Parameters
    ----------
    ORF_list : list
        List of ORFs.

    Returns
    -------
    Single ORF [start base, length].

    """
    # find longest ORF
    longest = max([i[1] for i in ORF_list])
    idx = [i[1] for i in ORF_list].index(longest) #then find it's index
    return(ORF_list[idx])

# Returns seq name, coordinates, and sequence of longest ORF in fasta dictionary
def maxORF_file(seq_dict):
    '''
    Returns longest ORF in a sequence dictionary, across all frames

    Parameters
    ----------
    seq_dict : dictionary
        Sequence dictionary

    Returns
    -------
    longest ORF as a list [sequence name, coordinates (two-item list) in 
                           python base 0, sequence, and frame].

    '''
    lngst = ['',[0,0], '', 0]
    for seq_nm in seq_dict:
        for frm in range(3):
            orfs = findORF(seq_nm, seq_dict, frm)
            # Must be ORF for this part, otherwise skip
            if len(orfs) != 0:
                locmx = maxORF(orfs)
                lngst = [seq_nm, locmx, seq_dict[seq_nm][0][locmx[0]-1:locmx[0]+locmx[1]-1], frm] if locmx[1] > lngst[1][1] else lngst
    return(lngst)

def maxORF_seq(seq_nm, seq_dict):
    """
    Finds longest Open Reading Frame (ORF) in one sequence across all frames

    Parameters
    ----------
    seq_nm : string
        Sequence name.
    seq_dict : TYPE
        Sequence dictionary.

    Returns
    -------
    longest ORF as a list [sequence name, coordinates (two-item list) in 
                           python base 0, sequence, and frame].

    """
    # returns seq name, coordinates, and sequence of longest ORF in fasta dictionary
    lngst = ['',[0,0], '', 0]
    for frm in range(3):
        orfs = findORF(seq_nm, seq_dict, frm)
        locmx = maxORF(orfs)
        lngst = [seq_nm, locmx, seq_dict[seq_nm][0][locmx[0]-1:locmx[0]+locmx[1]-1], frm] if locmx[1] > lngst[1][1] else lngst
    return(lngst)

def rpt_seq(seq_nm, seq_dict, length):
    """
    Produces a dictionary of occurences of repeats in a sequence, given a length.
    Can be overlapping. Note: Can't just use string.count('AAA'), misses overlaps

    Parameters
    ----------
    seq_nm : string
        Name of a sequence in the sequence dictionary
    seq_dict : dictionary
        A sequence dictionary
    length : integer
        Sequence length of interest.

    Returns
    -------
    Dictionary of all repeated sequences of given length; keys are the sequences,
    values are the count of repeats.

    """
    seq = seq_dict[seq_nm][0] #sequence
    #break sequence into all subsequences
    all_sqs = [seq[i:i+length] for i in range((len(seq)-length+1))]
    rept_dict = dict((x, all_sqs.count(x)) for x in set(all_sqs))
    return(rept_dict)

def rpt_seq_fl(seq_dict, length):
    """
    Finds all repeated sequence across a sequence dictionary

    Parameters
    ----------
    seq_dict : dictionary
        A sequence dictionary.
    length : integer
        Sequence length of interest.

    Returns
    -------
    Dictionary of dictionaries of all repeated sequences of given length; 
    Top level keyed to sequence name. Sub-dictionary keys are the repeated 
    sequences, values are the count of repeats.

    """
    # Builds a seq-name-wise dictionary of repeat dictionaries.
    rept_dict_fl = {}
    for seq_nm in seq_dict:
        rept_dict_fl[seq_nm] = rpt_seq(seq_nm, seq_dict, length)
    return(rept_dict_fl)
        
def comb_repseqs(repdicts):
    """
    Given a dictionary of repeat dictionaries, combines by summing values by 
    common keys. Works with other dictionaries of dictionaries.

    Parameters
    ----------
    repdicts : dictionary
        Dictionary of dictionaries of all repeated sequences of given length; 
        Top level keyed to sequence name. Sub-dictionary keys are the repeated 
        sequences, values are the count of repeats.

    Returns
    -------
    Combined dictionary with summed repeats across all sequences.

    """
    out_dict = {}
    for dct in repdicts:
        for ky in repdicts[dct]:
            if ky in out_dict:
                out_dict[ky] += repdicts[dct][ky]
            else:
                out_dict[ky] = repdicts[dct][ky]
    return(out_dict)

def freq_rep(in_dict):
    """
    Returns most frequent repeated sequence in a repeat dictionary. Also general
    function to find greatest value in dictionary.

    Parameters
    ----------
    in_dict : dictionary
        Any dictionary with numeric values.

    Returns
    -------
    Tuple of sequence name list and number of observations in sequence(s).

    """
    sq = [] #list of seq names
    max_rep = 0 #track greatest observed value
    for ky in in_dict:
        if in_dict[ky] > max_rep:
            sq = [ky]
            max_rep = in_dict[ky]
        elif in_dict[ky] == max_rep:
            sq.append(ky)
            max_rep = in_dict[ky]
    return((sq, max_rep))
    
    
    
